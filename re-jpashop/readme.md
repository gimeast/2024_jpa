## 엔티티 설계시 주의점

### 엔티티에는 가급적 Setter를 사용하지 말자
setter가 모두 열려있다면 변경포인트가 너무 많아서 유지보수가 어렵다.

### 모든 연관관계는 지연로딩으로 설정!
- 즉시로딩은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기 어렵다. 특히 JPQL을 실행할 때는 N+1 문제가 자주 발생한다.

### 컬렉션은 필드에서 초기화 하자.
컬렉션은 필드에서 바로 초기화 하는 것이 안전하다.
- null 문제에서 안전하다.


```
비즈니스 로직을 대부분 엔티티에서 하는 것을 
*도메인 모델 패턴*이라고 한다.
반대로 엔티티에 비즈니스 로직이 거의 없고 
서비스 계층에서 대부분의 비즈니스 로직을 처리하는 것을 
*트랜잭션 스크립트 패턴*이라 한다.
```

## 변경 감지와 병함(merge)
```
준영속 엔티티
- 영속성 컨텍스트가 더는 관리하지 않는 엔티티를 말한다.

Book book = new Book();
book.setId(bookForm.getId());
book.setName(bookForm.getName());
book.setPrice(bookForm.getPrice());
book.setStockQuantity(bookForm.getStockQuantity());
book.setAuthor(bookForm.getAuthor());
book.setIsbn(bookForm.getIsbn());
이렇게 식별자가 존재하도록 임의로 만들어낸 엔티티를 준영속 엔티티로 본다.
```

### 준영속 엔티티를 수정하는 2가지 방법
- 변경 감지 기능 사용
- 병합 사용




## 페치조인 주의점
컬렉션은 페치 조인하면 페이징이 불가능 하다.  
1대 N이기 때문에 데이터가 예측할 수 없이 증가하게 된다.  
하지만 이 상태에서 페이징을 하게 되면 N을 기준으로 페이징을 하게되는데
그 결과는 원하는 결과가 아니게 된다.  
distinct를 하여 중복 데이터를 줄이고 결과를 낼 수 도 있다.  
하지만 쿼리 결과를 확인하면 전체 조회를 하게되며
하이버네이트는 경고 로그를 남기고 모든 DB 데이터를 읽어서 메모리에서 페이징을 시도한다.  
out of memory가 발생할 수 있다.

### 해결방법
대부분의 페이징 + 컬렉션 엔티티 조회 문제는 아래 방법으로 해결이 가능하다.

*ToOne 관계는 모두 fetch join을 한다. *ToOne관계는 row 수를 증가 시키지 않으므로 페이징 쿼리에 영향을 주지 않는다.

해결방법1: `default로 걸어두는게 좋다.`
default_batch_fetch_size 또는 @BatchSize를 조절한다.
* default_batch_fetch_size : 글로벌 설정 100~1000 사이로 조절하는게 가장 좋다.(데이터베이스의 스펙에 의해 갈린다.)
* @BatchSize 개별 설정

batch fetch size를 설정하게 되면 in 쿼리로 변경되게 된다.  
쿼리 호출수가 1+N에서 1+1로 최적화 된다.  
`결론:ToOne관계는 fetch join으로 쿼리수를 줄이고 나머지는 batch fetch size로 최적화 하자`



## API 개발 고급 정리
* 엔티티 조회
  * 엔티티를 조회해서 그대로 반환: V1
  * 엔티티 조회 후 DTO로 변환: V2
  * 페치 조인으로 쿼리 수 최적화: V3
  * 컬렉션 페이징과 한계 돌파: V3.1
    * 컬렉션은 페치 조인시 페이징 불가능
    * ToOne 관계는 페치 조인으로 쿼리 수 최적화
    * 컬렉션은 페치 조인 대신에 지연 로딩을 유지하고, `default_batch_fetch_size`, `@BatchSize`로 최적화
* DTO 직접 조회
  * JPA에서 DTO를 직접 조회: V4
  * 컬렉션 조회 최적화 - 일대다 관계인 컬렉션은 IN 절을 활용해서 메모리에 미리 조회해서 최적화: V5
  * 플랫 데이터 최적화 - JOIN 결과를 그대로 조인 후 애플리케이션에서 원하는 모양으로 직접 변환: V6


### 권장 순서
1. 엔티티 조회 방식으로 우선 접근
   1. 페치 조인으로 쿼리 수를 최적화
   2. 컬렉션 최적화
      1. 페이징 필요시 `default_batch_fetch_size`, `@BatchSize`로 최적화
      2. 페이징 필요X -> 페치 조인 사용
2. 엔티티 조회 방식으로 해결이 안되면 DTO 조회 방식 사용
3. DTO 조회 방식으로 해결이 안되면 NativeSQL or 스프링 JdbcTemplate

```
참고: 엔티티 조회 방식은 페치 조인이나, default_batch_fetch_size, @BatchSize
같이 코드를 거의 수정하지 않고, 옵션만 약간 변경해서, 다양한 성능 최적화를 시도할 수 있다.
반면에 DTO를 직접 조회하는 방식은 성능을 최적화 하거나 성능 최적화 방식을 변경할 때 많은 코드를 변경해야 한다.
```

## OSIV와 성능 최적화
* Open Session In View: 하이버네이트
* Open EntityManager In View: JPA
(관례상 OSIV라 한다.)

`spring.jpa.open-in-view`: true 기본값
이 기본값을 뿌리면서 애플리케이션 시작 시점에 warn 로그를 남기는 것은 이유가 있다.  
OSIV 전략은 트랜잭션 시작처럼 최초 데이터베이스 커넥션 시작 시점부터 API 응답이 끝날 때 까지 영속성 컨텍스트와
데이터베이스 커넥션을 유지한다.  
그래서 지금까지 View Template이나 API 컨트롤러에서 지연 로딩이 가능 했던 것.  
지연 로딩은 영속성 컨텍스트가 살아있어야 가능하고, 영속성 컨텍스트는 기본적으로 데이터베이스 커넥션을 유지한다.  
이것 자체가 큰 장점이다.

그러나 이 전략은 너무 오랜시간동안 데이터베이스 커넥션 리소스를 사용하기 때문에, 
실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 모자랄 수 있다.  
이것은 결국 장애로 이어진다.
예를 들어 컨트롤러에서 외부 API를 호출하면 외부 API 대기시간 만큼 커넥션 리소스를 반환하지 못하고, 유지해야 한다.


`spring.jpa.open-in-view: false` OSIV 종료
OSIV를 끄면 트랜잭션을 종료할 때 영속성 컨텍스트를 닫고, 데이터베이스 커넥션도 반환한다.
따라서 커넥션 리소스를 낭비하지 않는다.
OSIV를 끄면 모든 지연로딩을 트랜잭션 안에서 처리해야 한다.
따라서 지금까지 작성한 많은 지연 로딩 코드를 트랜잭션 안으로 넣어야 하는 단점이 있다.
그리고 view template에서 지연로딩이 동작하지 않는다.
결론적으로 트랜잭션이 끝나기 전에 지연 로딩을 강제로 호출해 두어야 한다.







